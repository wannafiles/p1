<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PAC-RACER</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            background-color: #222;
            flex-direction: column;
            font-family: Arial, sans-serif;
            color: white;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            /* ã‚¹ãƒ¯ã‚¤ãƒ—æ“ä½œã«ã‚ˆã‚‹ç”»é¢ã®æ‹¡å¤§ç¸®å°ã‚„ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’é˜²æ­¢ï¼ˆç‰¹ã«iOSï¼‰ */
            touch-action: manipulation; 
        }
        #game-container {
            width: 100%;
            max-width: 360px;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 auto;
ã€€ã€€ã€€ã€€ã€€         }
        /* ===== ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”»é¢ã‚¹ã‚¿ã‚¤ãƒ« ===== */



        #start-menu, #grandprix-results {
            width: 100%;
            padding: 10px;
            background-color: #333;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            text-align: center;
        }
        .mode-button {
            padding: 10px 15px;
            font-size: 16px;
            cursor: pointer;
            margin: 5px;
            /* å¤‰æ›´å‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: background-color: #00FF00; */
            background-color: #FF4444; 
            color: #FFF;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            width: 80%;
            box-sizing: border-box;
        }
        .mode-button.race-mode {
            background-color: #FFC000; /* ã‚°ãƒ©ãƒ³ãƒ—ãƒªãƒ¢ãƒ¼ãƒ‰ã¯é»„è‰² */
            color: #000; 
            font-size: 20px; /* 1P, 2Pã‚’åˆ†ã‘ã¦ãƒœã‚¿ãƒ³ã‚µã‚¤ã‚ºã‚’èª¿æ•´ */
            margin-bottom: 5px;
        }
        /* ğŸš€ è¿½åŠ : 2Pãƒ¢ãƒ¼ãƒ‰ã®ãƒœã‚¿ãƒ³ã‚«ãƒ©ãƒ¼ */
        .mode-button.race-mode-2p {
            background-color: #00AAFF; /* 2Pãƒ¢ãƒ¼ãƒ‰ã¯é’è‰² */
            color: #FFF;
            font-size: 20px;
            margin-bottom: 15px;
        }

	.pac-racer-title {
    	    color: yellow;
    	    font-size: 36px; 
    	    font-weight: bold;
	}
	
	.explanation {
    	    color: white;
    	    font-size: 14px; 
            text-align: center;
	}
	ã€€ã€€
        
        /* --- ğŸš€ ã‚³ãƒ¼ã‚¹åˆ¥ã‚«ãƒ©ãƒ¼ã®è¿½åŠ  --- */
        .mode-button.track1-color {
            background-color: #FF4444; /* èµ¤ */
            color: #FFF;
        }
        .mode-button.track2-color {
            background-color: #44FFFF; /* æ°´è‰²/ã‚·ã‚¢ãƒ³ */
            color: #000;
        }
        .mode-button.track3-color {
            background-color: #FF8800; /* æ©™è‰² */
            color: #FFF;
        }
        /* ğŸš€ è¿½åŠ : PINKã‚³ãƒ¼ã‚¹ã®ã‚«ãƒ©ãƒ¼ */
        .mode-button.track4-color {
            background-color: #FF69B4; /* ãƒ”ãƒ³ã‚¯ */
            color: #FFF;
        }
        /* -------------------------- */
        
        /* å¤‰æ›´ç‚¹: ãƒ™ã‚¹ãƒˆã‚¿ã‚¤ãƒ è¡¨ç¤ºç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .best-time-display {
            display: block;
            margin-top: 2px; /* ãƒœã‚¿ãƒ³ã¨ã®é–“éš”ã‚’è©°ã‚ã‚‹ */
            margin-bottom: 10px; /* æ¬¡ã®ãƒœã‚¿ãƒ³ã¨ã®é–“éš” */
            color: #000;
            font-size: 14px;
            font-weight: bold;
        }
        /* ğŸš€ 2Pãƒ™ã‚¹ãƒˆã‚¿ã‚¤ãƒ è¡¨ç¤ºç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .best-time-display.grandprix-2p {
            color: #FFF; /* 2Pãƒœã‚¿ãƒ³ã®æ–‡å­—è‰²ã«åˆã‚ã›ã‚‹ */
        }
        #start-menu .best-time-display:last-of-type {
            margin-bottom: 0;
        }
        #start-menu hr {
             /* ãƒ™ã‚¹ãƒˆã‚¿ã‚¤ãƒ è¡¨ç¤ºã¨ã®é–“éš”ã‚’èª¿æ•´ */
            margin-top: 15px;
        }


        /* ===== ã‚²ãƒ¼ãƒ UIã‚¹ã‚¿ã‚¤ãƒ« (ä¿®æ­£/è¿½åŠ ) ===== */
        #game-info {
            width: 100%;
            margin-bottom: 0px; /* ã‚­ãƒ£ãƒ³ãƒã‚¹ã¨ã®é–“éš”ã‚’å°‘ã—è©°ã‚ã‚‹ */
            font-size: 20px;
            text-align: center;
        }
       #game-ui {
            flex-direction: column; /* ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç¸¦ã«ä¸¦ã¹ã‚‹ */
            align-items: center;    /* ä¸­å¤®æƒãˆã«ã™ã‚‹ */
            width: 100%;            /* è¦ªè¦ç´ ã®å¹…ã«åˆã‚ã›ã‚‹ */
        }
        
        /* ğŸš€ è¿½åŠ : ãƒ©ãƒƒãƒ—æ•°ã¨ç¾åœ¨ã®ã‚¿ã‚¤ãƒ ã‚’æ¨ªä¸¦ã³ã«ã™ã‚‹ã‚¹ã‚¿ã‚¤ãƒ« */
        #lap-and-time-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 90%; /* ä¸­å¤®æƒãˆã®ãŸã‚å¹…ã‚’åˆ¶é™ */
            margin: 0 auto;
            font-size: 20px;
            font-weight: bold;
        }
        
        /* ğŸš€ è¿½åŠ : ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡¨ç¤º */
        #current-player-display {
             font-size: 20px;
             font-weight: bold;
             color: #FFF;
             flex: 1; 
             text-align: center;
             /* æ—¢å­˜ã®current-time-displayã‚„current-best-time-displayã®é…ç½®ã‚’èª¿æ•´ */
             margin-top: 5px; 
             margin-bottom: 5px;
        }

        /* ğŸš€ ä¿®æ­£: ãƒ©ãƒƒãƒ—ã‚¿ã‚¤ãƒ å±¥æ­´ã¨ãƒˆãƒ¼ã‚¿ãƒ«ã‚¿ã‚¤ãƒ ã®4åˆ—è¡¨ç¤ºã‚¹ã‚¿ã‚¤ãƒ« */
        #simple-lap-display {
            display: grid; 
            grid-template-columns: repeat(4, 1fr); /* 4åˆ— (Lap1, Lap2, Lap3, Total) */
            grid-template-rows: auto auto; /* 2è¡Œ (ãƒ©ãƒ™ãƒ«, ã‚¿ã‚¤ãƒ ) */
            gap: 0px; /* éš™é–“ãªã— */
            width: 100%; /* æœ€å¤§å¹…ã„ã£ã±ã„ã«åºƒã’ã‚‹ */
            max-width: 360px; /* ã‚³ãƒ³ãƒ†ãƒŠã®æœ€å¤§å¹…ã«åˆã‚ã›ã‚‹ */
            margin: 0px auto 0 auto; /* ä¸­å¤®æƒãˆã«å¤‰æ›´ */
            /* â–¼â–¼â–¼â–¼â–¼ ä¿®æ­£: ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’æœ€å°ã«ã—ã€èƒŒæ™¯è‰²ã‚’é»’ã«ã™ã‚‹ â–¼â–¼â–¼â–¼â–¼ */
            padding: 0px 0; /* ä¸Šä¸‹ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’æœ€å°(5pxã‹ã‚‰2pxã¸) */
            background-color: #222; /* èƒŒæ™¯è‰²ã‚’é»’ã«å¤‰æ›´ */
            /* â–²â–²â–²â–²â–² ä¿®æ­£ â–²â–²â–²â–²â–² */
            border-radius: 5px;
            font-size: 14px; 
            font-weight: bold;
            text-align: center;
        }
        
        .lap-header-item {
            /* 1è¡Œç›®ã®ã‚¹ã‚¿ã‚¤ãƒ« (Lap 1, Lap 2, Lap 3, Total:) */
            text-align: center; /* ä¸­å¤®å¯„ã› */
            padding: 3px 0;
            color: #DDD;
            border-bottom: 1px solid #777; /* åŒºåˆ‡ã‚Šç·š */
        }
        
        .lap-time-value {
            /* 2è¡Œç›®ã®ã‚¹ã‚¿ã‚¤ãƒ« (ã‚¿ã‚¤ãƒ ã®å€¤) */
            text-align: center; /* ä¸­å¤®å¯„ã› */
            padding: 3px 0;
            color: #DDD;
            font-size: 16px; /* å€¤ã‚’å°‘ã—å¤§ãã */
        }
        
        /* 4åˆ—ç›® (Total) ã®ç‰¹åˆ¥ãªã‚¹ã‚¿ã‚¤ãƒ« */
        .total-style-header {
            color: #FFC000; /* é»„è‰² */
            font-size: 16px;
            border-bottom: 1px solid #FFC000; /* åŒºåˆ‡ã‚Šç·šã‚’é»„è‰²ã« */
        }
        .total-style-value {
            color: #FFC000; /* é»„è‰² */
            font-size: 18px; /* å€¤ã‚’ã•ã‚‰ã«å¤§ãã */
        }
        
        /* -------------------------- */


        /* å‰Šé™¤: #lap-times, .lap-time-row, #boost-hint ã®ã‚¹ã‚¿ã‚¤ãƒ«ã¯å‰Šé™¤ */
        
        #gameCanvas {
            max-width: 360px;
            width: 100%;
            height: auto;
            border: 5px solid #000;
            background-color: #000;
            /* ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã§ã®ã‚¿ãƒƒãƒæ“ä½œã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒèµ·ããªã„ã‚ˆã†ã«ã™ã‚‹ */
            touch-action: none;
        }
        
        #startButton {
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            margin-top: 10px;
            background-color: #00FF00;
            color: #000;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            /* å¤‰æ›´: mode-button ã‚¯ãƒ©ã‚¹ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’é©ç”¨ã™ã‚‹ãŸã‚å¹…ã‚’æŒ‡å®š */
            width: 90%;
            box-sizing: border-box;
        }
        #startButton.race-mode {
            background-color: #FFC000;
        }
        /* ğŸš€ 2Pãƒ¢ãƒ¼ãƒ‰ã®startButton */
        #startButton.race-mode-2p {
            background-color: #00AAFF;
            color: #FFF;
        }
        #countdown-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 100px;
            color: red;
            font-weight: bold;
            text-shadow: 0 0 10px black;
            z-index: 10;
        }
        
        /* ===== ğŸš€ ç”°ã®å­—ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç”¨ã‚¹ã‚¿ã‚¤ãƒ« (ã“ã“ã‹ã‚‰è¿½åŠ ) ===== */
        #track-grid {
            display: grid;
            grid-template-columns: 1fr 1fr; /* 2åˆ— */
            gap: 10px; /* ãƒœã‚¿ãƒ³é–“ã®éš™é–“ */
            width: 90%; /* å…¨ä½“ã®å¹… */
            margin: 0px auto 0 auto; /* ä¸Šä¸‹ã«ãƒãƒ¼ã‚¸ãƒ³ã€å·¦å³ä¸­å¤®æƒãˆ */
        }
        
        #track-grid .mode-button {
            width: 100%; /* ã‚°ãƒªãƒƒãƒ‰ã‚»ãƒ«ã„ã£ã±ã„ã«åºƒã’ã‚‹ (90%ã‚’ä¸Šæ›¸ã) */
            height: 50px;  /* é«˜ã•ã‚’æŒ‡å®šã—ã¦æ­£æ–¹å½¢ã«è¿‘ã¥ã‘ã‚‹ */
            margin: 0;     /* ãƒãƒ¼ã‚¸ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆ */
            display: flex;
            flex-direction: column; /* ä¸­èº«ã‚’ç¸¦ã«ä¸¦ã¹ã‚‹ */
            justify-content: center;
            align-items: center;
            font-size: 18px; /* ãƒˆãƒ©ãƒƒã‚¯åã‚’å¤§ãã */
            padding: 5px;
        }
        
        #track-grid .best-time-display {
            margin: 5px 0 0 0; /* ãƒˆãƒ©ãƒƒã‚¯åã¨ã®é–“ã«ãƒãƒ¼ã‚¸ãƒ³ */
            font-size: 14px;
            color: inherit; /* ãƒœã‚¿ãƒ³ã®æ–‡å­—è‰²ã‚’ç¶™æ‰¿ (ç™½ or é»’) */
            /* .best-time-display ã®ãƒãƒ¼ã‚¸ãƒ³è¨­å®šã‚’ä¸Šæ›¸ã */
        }
        /* ------------------------------------- (ã“ã“ã¾ã§è¿½åŠ ) */
    </style>
</head>
<body>

    <div id="game-container">
        
        <div id="start-menu">
PAC-MAN Ã— RACE Ã— PUZZLE<BR>
<span class="explanation">ãƒ‘ãƒƒã‚¯ãƒãƒ³ãŒè¿·è·¯ã§ãƒ¬ãƒ¼ã‚¹å¤§ä¼šï¼?<BR>
äº¤å·®ç‚¹ã¯çµ¶å¯¾ç›´é€²ã€ çªãå½“ã‚Šã§ã‚¿ãƒ¼ãƒ³!<BR>
æœ€çŸ­ãƒ«ãƒ¼ãƒˆã¨ã‚¿ãƒ¼ãƒ³åŠ é€Ÿã§è¨˜éŒ²æ›´æ–°ã ï¼</span>
ã€€ã€€ã€€ã€€ã€€ã€€<hr style="border-top: 1px solid #777; width: 90%;">
	    <span class="pac-racer-title">ğŸ†P1 GRAND PRIX</span>
            <p>ï¼”ã‚³ãƒ¼ã‚¹ã€å„ï¼“å‘¨ã®ã‚°ãƒ©ãƒ³ãƒ—ãƒªãƒ¬ãƒ¼ã‚¹</p>
            
            <button id="grandPrixButton1P" class="mode-button race-mode">SOLO RACE
<div id="bestGrandPrixTimeDisplay1P" class="best-time-display">Best: --:--.---</div> </button>
            
            <button id="grandPrixButton2P" class="mode-button race-mode-2p">MATCH RACE -2På¯¾æˆ¦
<div id="bestGrandPrixTimeDisplay2P" class="best-time-display grandprix-2p">Best: --:--.---</div> </button>
           
            <hr style="border-top: 1px solid #777; width: 90%;">
            <p>ã‚³ãƒ¼ã‚¹ã‚’é¸ã‚“ã§ç·´ç¿’èµ°è¡Œ</p>
            
            <div id="track-grid">
                <button id="track1Button" class="mode-button track1-color" data-track-index="0">
                    RED
                    <div id="bestTimeTrack0" class="best-time-display">Best: --:--.---</div>
                </button>
                <button id="track2Button" class="mode-button track2-color" data-track-index="1">
                    BLUE
                    <div id="bestTimeTrack1" class="best-time-display">Best: --:--.---</div>
                </button>
                <button id="track3Button" class="mode-button track3-color" data-track-index="2">
                    ORANGE
                    <div id="bestTimeTrack2" class="best-time-display">Best: --:--.---</div>
                </button>
                <button id="track4Button" class="mode-button track4-color" data-track-index="3">
                    PINK
                    <div id="bestTimeTrack3" class="best-time-display">Best: --:--.---</div>
                </button>
            </div>
            <hr style="border-top: 1px solid #777; width: 90%;">

            <button id="gyroControlButton" class="mode-button" style="margin-top: 15px; background-color: #FF9800;">
                <span style="color: yellow;">â–¶</span> ã‚¸ãƒ£ã‚¤ãƒ­æ“ä½œã‚’æœ‰åŠ¹åŒ–
            </button>
            
        </div>
       
 <div id="grandprix-results" style="display: none; margin-top: 10px;">
            <h2>ğŸ† ç·åˆçµæœ</h2>
            <div id="grandprix-score-list"></div>
            <hr style="border-top: 1px solid #777; width: 90%;">
            <div id="grandprix-total-time" style="font-size: 20px; font-weight: bold; margin-top: 10px;"></div>
            <button id="resultButton" class="mode-button" style="margin-top: 15px;">ãƒœã‚¿ãƒ³</button>
        </div>

        <div id="game-ui" style="display: none;">
          ã€€<div id="game-info">
              <div id="lap-and-time-row">
                  <div id="current-time-display" style="flex: 1; text-align: left; font-weight: bold;">00.000</div>
                  <div id="current-best-time-display" style="flex: 1; text-align: right; font-weight: bold;">BEST: --:--.---</div>
              </div>
              </div>
            
            <canvas id="gameCanvas" width="360" height="396"></canvas>
           
            <div id="simple-lap-display">
                <div class="lap-header-item">Lap 1</div>
                <div class="lap-header-item">Lap 2</div>
                <div class="lap-header-item">Lap 3</div>
                <div class="lap-header-item total-style-header">Total:</div>
                
                <div id="lap1-time" class="lap-time-value">--.---</div>
                <div id="lap2-time" class="lap-time-value">--.---</div>
                <div id="lap3-time" class="lap-time-value">--.---</div>
                <div id="total-time" class="lap-time-value total-style-value">--:--.---</div>
            </div>
            <button id="startButton">ãƒ¬ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
            
            <button id="returnToMenuButtonGame" class="mode-button" style="margin-top: 10px; background-color: #888;">ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>
               <div id="current-player-display" style="display:none"></div>
          
        </div>
    </div>
    
    <div id="countdown-display"></div>

    <script>
        // ... (æ—¢å­˜ã®canvas, ctx, å„ç¨®è¦ç´ ã®å–å¾—) ...
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const timeDisplay = document.getElementById('current-time-display');
        const startButton = document.getElementById('startButton');
        const countdownDisplay = document.getElementById('countdown-display');

        // æ–°è¦è¿½åŠ è¦ç´ 
        const startMenu = document.getElementById('start-menu');
        const gameUI = document.getElementById('game-ui');
        const grandPrixResultsDiv = document.getElementById('grandprix-results');
        const grandPrixScoreList = document.getElementById('grandprix-score-list');
        const grandPrixTotalTime = document.getElementById('grandprix-total-time');
        
        // ğŸš€ ä¿®æ­£: çµæœç”»é¢ã®ãƒœã‚¿ãƒ³IDã‚’å¤‰æ›´
        const resultButton = document.getElementById('resultButton'); 
        
        const currentBestTimeDisplay = document.getElementById('current-best-time-display');
        const currentPlayerDisplay = document.getElementById('current-player-display');

        const lap1TimeDisplay = document.getElementById('lap1-time');
        const lap2TimeDisplay = document.getElementById('lap2-time');
        const lap3TimeDisplay = document.getElementById('lap3-time');
        const totalTimeDisplay = document.getElementById('total-time');
        
        const grandPrixButton1P = document.getElementById('grandPrixButton1P');
        const grandPrixButton2P = document.getElementById('grandPrixButton2P');
        const bestGrandPrixTimeDisplay1P = document.getElementById('bestGrandPrixTimeDisplay1P');
        const bestGrandPrixTimeDisplay2P = document.getElementById('bestGrandPrixTimeDisplay2P');


        // === ã‚²ãƒ¼ãƒ å®šæ•° ===
        // ... (å¤‰æ›´ãªã—) ...
        const TILE_SIZE = 36; 
        const PACMAN_SIZE = 30;
        const NORMAL_SPEED = 3; 
        const BOOST_SPEED = 6;  
        const BOOST_DURATION_MS = 200; 
        const TIMING_WINDOW_MS = 50; 
        const MAX_LAPS = 3;
        
        // ğŸš€ è¿½åŠ : ã‚¹ãƒ¯ã‚¤ãƒ—æ“ä½œç”¨å®šæ•°
        const SWIPE_THRESHOLD = 20; // ã‚¹ãƒ¯ã‚¤ãƒ—ã¨èªè­˜ã™ã‚‹æœ€å°ãƒ”ã‚¯ã‚»ãƒ«æ•°
        
        // ğŸš€ è¿½åŠ : ã‚¸ãƒ£ã‚¤ãƒ­æ“ä½œç”¨å®šæ•°
        const TILT_THRESHOLD = 5; // ç§»å‹•ã‚’é–‹å§‹ã™ã‚‹å‚¾ãã®æœ€å°è§’åº¦ï¼ˆåº¦ï¼‰

	// åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼æ“ä½œã®ãŸã‚ã®é–¾å€¤ (m/s^2)
	// ã“ã®å€¤ã¯ã€ãƒ†ã‚¹ãƒˆãƒ—ãƒ¬ã‚¤ã‚’é€šã˜ã¦èª¿æ•´ãŒå¿…è¦ã§ã™
	const ACCEL_THRESHOLD = 5.0;

        const TRACK_COLORS = [
            '#FF4444', // Maze 1 (èµ¤è‰²ãƒ™ãƒ¼ã‚¹)
            '#44FFFF', // Maze 2 (æ°´è‰²ãƒ™ãƒ¼ã‚¹)
            '#FF8800',  // Maze 3 (æ©™è‰²ãƒ™ãƒ¼ã‚¹)
            '#FF69B4'   // Maze 4 (ãƒ”ãƒ³ã‚¯è‰²ãƒ™ãƒ¼ã‚¹)
        ];

        const TRACKS = [
            { name: "RED", map: [
"MMMMMMMMM", 
"M...M...M", 
"M.M.M.M.M", 
"M.......M", 
"M.M.M.MMM", 
"....M....", 
"MMM.M.M.M", 
"M...P...M", 
"M.M.M.M.M", 
"M...M...M", 
"MMMMMMMMM"] },

            { name: "BLUE", map: [
"MMMMMMMMM", 
"M...MMMMM", 
"M.M...MMM", 
"M.M.M.MMM", 
"M.M......", 
"M.M.M.M.M", 
"....P.M.M", 
"MMM.M.M.M", 
"MMM...M.M", 
"MMMMM...M", 
"MMMMMMMMM",] },

            { name: "ORANGE", map: [
"MMMMMMMMMM", 
"M......MMM", 
"M.M.MM.MMM", 
"M.M......M", 
"M.M.MM.M.M", 
".........M", 
"MMM.MM.MMM", 
"M....P....", 
"M.M.MM.M.M", 
"M......M.M", 
"MMM.MM.M.M", 
"MMM......M", 
"MMMMMMMMMM"] },

            { name: "PINK", map: [
"MMMMMMMMM", 
"M..M....M", 
"M.....M.M", 
"M.MMM.M.M", 
"M.M.....M", 
"M.M.M.MMM", 
"....M....", 
"MMM.M.M.M", 
"M...P.M.M", 
"M.M.MMM.M", 
"M.M.....M", 
"M....M..M", 
"MMMMMMMMM"] }
        ];


        // === ã‚²ãƒ¼ãƒ çŠ¶æ…‹å¤‰æ•° ===
        // ğŸš€ ä¿®æ­£: SHOWING_INTERIM_RESULTS ã‚’è¿½åŠ 
        let gameState = 'MENU'; // MENU, READY, COUNTDOWN, RACE, FINISHED, FINISHED_RESTART, TRACK_FINISHED_WAIT, GRAND_PRIX_RESULTS, GRAND_PRIX_WAIT, SHOWING_INTERIM_RESULTS
        let gameMode = 'SINGLE_RACE'; 
        let currentTrackIndex = 0; 
        
        let grandPrixData = {
            player1: { name: "PLAYER 1", results: [] }, 
            player2: { name: "PLAYER 2", results: [] } 
        }; 
        let currentPlayer = 'player1'; 
        let totalGrandPrixTime = 0; 
        
        let flashIntervalId = null; 
        let flashCount = 0; 
        const FLASH_MAX = 8; 
        
        let currentMazeColor = '#0000FF';
        
        let bestSingleRaceTimes = new Array(TRACKS.length).fill(Infinity);
        let bestGrandPrixTime1P = Infinity; 
        let bestGrandPrixTime2P = Infinity; 
        
        // ğŸš€ è¿½åŠ : ã‚¹ãƒ¯ã‚¤ãƒ—æ“ä½œç”¨çŠ¶æ…‹å¤‰æ•°
        let touchStartX = 0;
        let touchStartY = 0;
        
        // ğŸš€ è¿½åŠ : ã‚¸ãƒ£ã‚¤ãƒ­æ“ä½œç”¨çŠ¶æ…‹å¤‰æ•°
        let isGyroControlActive = false;
        let controlMode = 'SWIPE'; // SWIPE, GYRO, KEYBOARD ã®ã„ãšã‚Œã‹
let inputDirection = { x: 0, y: 0 };

        let MAP = [];
        let MAP_WIDTH = 0;
        let MAP_HEIGHT = 0;
        let initialPacmanX = 0;
        let initialPacmanY = 0;
        
        let remainingCookies = 0;
        let score = 0;
        let grid = [];
        let currentLap = 1;
        let lapTimes = [];
        let lapStartTime = 0; 
        let countdownTimer;

        let pacman = {
            x: 0, y: 0, dx: 0, dy: 0, nextDx: 0, nextDy: 0,
            isBoosting: false, boostEndTime: 0, turnAttemptTime: 0, stoppedTime: 0      
		// å·¦å³ãƒ»å‰å¾Œå…¥åŠ›ã®ç¾åœ¨ã®å€¤
	
        };
        
        // ğŸš€ è¿½åŠ : ã‚°ãƒ©ãƒ³ãƒ—ãƒªé€”ä¸­çµæœè¡¨ç¤ºç”¨ã®ä¸€æ™‚å¤‰æ•°
        let nextTrackForGP = 0;
        let nextPlayerForGP = 'player1';


        // --- é–¢æ•°å®šç¾© ---
        
        function formatTime(ms) {
            const sign = ms < 0 ? "-" : "";
            const absMs = Math.abs(ms);
            const totalSeconds = Math.floor(absMs / 1000); 
            const milliseconds = absMs % 1000;
            const secStr = String(totalSeconds).padStart(2, '0');
            const msStr = String(milliseconds).padStart(3, '0');
            return `${sign}${secStr}.${msStr}`;
        }

        function formatTotalTime(ms) {
            const sign = ms < 0 ? "-" : "";
            const absMs = Math.abs(ms);
            const totalSeconds = Math.floor(absMs / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const milliseconds = absMs % 1000;
            const minStr = String(minutes).padStart(2, '0');
            const secStr = String(seconds).padStart(2, '0');
            const msStr = String(milliseconds).padStart(3, '0');
            return `${sign}${minStr}:${secStr}.${msStr}`;
        }
        
        function setupTrack(trackIndex) {
            const track = TRACKS[trackIndex];
            MAP = track.map;
            MAP_WIDTH = MAP[0].length;
            MAP_HEIGHT = MAP.length; 
            
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    if (MAP[y][x] === 'P') {
                        initialPacmanX = x * TILE_SIZE + TILE_SIZE / 2;
                        initialPacmanY = y * TILE_SIZE + TILE_SIZE / 2;
                        return;
                    }
                }
            }
        }

        /**
         * ğŸš€ ä¿®æ­£: resetCookiesForNextLap é–¢æ•°
         */
        function resetCookiesForNextLap() {
            remainingCookies = 0;
            grid = []; // ã‚°ãƒªãƒƒãƒ‰ã‚’åˆæœŸåŒ–
            for (let y = 0; y < MAP_HEIGHT; y++) {
                grid[y] = grid[y] || [];
                for (let x = 0; x < MAP_WIDTH; x++) {
                    const char = MAP[y][x];
                    if (char === 'M') {
                        grid[y][x] = 0; // ğŸš€ å£ã¯ 0
                    } else if (char === 'P' || char === ' ') { // ğŸš€ ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã¨ç©ºç™½ã¯ 2
                        grid[y][x] = 2;
                    } else { // '.' ãƒ‰ãƒƒãƒˆ (ã‚¯ãƒƒã‚­ãƒ¼)
                        grid[y][x] = 1; // ğŸš€ ãƒ‰ãƒƒãƒˆã¯ 1
                        remainingCookies++;
                    }
                }
            }
        }

        function initializeGame(mode, trackIndex, player = 'player1') { 
            gameMode = mode;
            currentTrackIndex = trackIndex;
            gameState = 'READY';
            
            if (gameMode === 'GRAND_PRIX_2P') {
                 currentPlayer = player;
            } else if (gameMode === 'GRAND_PRIX_1P') {
                 currentPlayer = 'player1'; 
            }
            
            setupTrack(currentTrackIndex);
            currentMazeColor = TRACK_COLORS[currentTrackIndex];
            
            canvas.width = MAP_WIDTH * TILE_SIZE;
            canvas.height = MAP_HEIGHT * TILE_SIZE; 
            grid = [];
            resetCookiesForNextLap(); // ğŸš€ ä¿®æ­£ã•ã‚ŒãŸé–¢æ•°ã‚’å‘¼ã¶
            pacman.x = initialPacmanX;
            pacman.y = initialPacmanY;
            pacman.dx = 0;
            pacman.dy = 0;
            pacman.nextDx = 0;
            pacman.nextDy = 0;
            pacman.isBoosting = false;
            pacman.boostEndTime = 0;
            pacman.turnAttemptTime = 0;
            pacman.stoppedTime = Date.now();
            currentLap = 1;
            lapTimes = [];
            
            timeDisplay.textContent = '00.000';
            countdownDisplay.textContent = '';
            
            lap1TimeDisplay.textContent = '--.---'; 
            lap2TimeDisplay.textContent = '--.---'; 
            lap3TimeDisplay.textContent = '--.---'; 
            totalTimeDisplay.textContent = '--:--.---'; 

            startMenu.style.display = 'none';
            grandPrixResultsDiv.style.display = 'none'; // å¸¸ã«éè¡¨ç¤ºã«
            gameUI.style.display = 'flex';
            
            if (currentPlayerDisplay) { 
                if (gameMode === 'GRAND_PRIX_2P') {
                     currentPlayerDisplay.textContent = `${grandPrixData[currentPlayer].name}ã®ç•ª (${TRACKS[currentTrackIndex].name}ã‚³ãƒ¼ã‚¹)`;
                     currentPlayerDisplay.style.color = currentPlayer === 'player1' ? '#FFC000' : '#00AAFF';
                } else {
                     currentPlayerDisplay.textContent = ''; 
                }
            }

            const bestTime = bestSingleRaceTimes[currentTrackIndex];
            if (currentBestTimeDisplay) {
                currentBestTimeDisplay.textContent = bestTime === Infinity ? 'BEST: --:--.---' : `BEST: ${formatTotalTime(bestTime)}`;
            }


            if (gameMode === 'SINGLE_RACE') {
                startButton.textContent = 'ãƒ•ãƒªãƒ¼èµ°è¡Œé–‹å§‹';
                startButton.classList.remove('race-mode', 'race-mode-2p', 'track1-color', 'track2-color', 'track3-color', 'track4-color');
            } else if (gameMode === 'GRAND_PRIX_1P') {
                startButton.textContent = '3LAPã‚¿ã‚¤ãƒ ãƒ¬ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ¼ãƒˆ';
                startButton.classList.add('race-mode');
                startButton.classList.remove('race-mode-2p');
                applyTrackColorToButton(currentTrackIndex);
            } else if (gameMode === 'GRAND_PRIX_2P') { 
                startButton.textContent = `${grandPrixData[currentPlayer].name}ã‚¹ã‚¿ãƒ¼ãƒˆï¼`;
                startButton.classList.add('race-mode-2p');
                startButton.classList.remove('race-mode');
                applyTrackColorToButton(currentTrackIndex);
            }
            
            startButton.disabled = false;
            
            if (!window.gameLoopRunning) {
                window.gameLoopRunning = true;
                gameLoop();
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMaze();
            drawCookies(); // ğŸš€ åˆå›æç”»æ™‚ã«ã‚‚ãƒ‰ãƒƒãƒˆã‚’æç”»
            drawPacman();
        }
        
        function applyTrackColorToButton(trackIndex) {
             startButton.classList.remove('track1-color', 'track2-color', 'track3-color', 'track4-color');
             if (trackIndex === 0) startButton.classList.add('track1-color');
             else if (trackIndex === 1) startButton.classList.add('track2-color');
             else if (trackIndex === 2) startButton.classList.add('track3-color');
             else if (trackIndex === 3) startButton.classList.add('track4-color');
        }

        function startCountdown() {
            gameState = 'COUNTDOWN';
            startButton.disabled = true;
            let count = 3;
            countdownDisplay.style.color = 'yellow';
            timeDisplay.textContent = 'READY';
            countdownDisplay.textContent = count;
            
            if (currentPlayerDisplay) { 
                if (gameMode === 'GRAND_PRIX_2P') {
                     currentPlayerDisplay.textContent = `${grandPrixData[currentPlayer].name} - READY (${TRACKS[currentTrackIndex].name}ã‚³ãƒ¼ã‚¹)`;
                }
            }

            countdownTimer = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownDisplay.textContent = count;
                } else if (count === 0) {
                    countdownDisplay.textContent = 'GO!';
                    countdownDisplay.style.color = 'lime';
                    
                    gameState = gameMode === 'SINGLE_RACE' ? 'FREE_RUN' : 'RACE';
                    lapStartTime = Date.now();
                    
                    if (gameMode === 'GRAND_PRIX_2P') {
                        startButton.textContent = `${grandPrixData[currentPlayer].name} RACING...`;
                        startButton.disabled = true; 
                        if (currentPlayerDisplay) { 
                           currentPlayerDisplay.textContent = `${grandPrixData[currentPlayer].name} - GO! (${TRACKS[currentTrackIndex].name}ã‚³ãƒ¼ã‚¹)`;
                        }
                    } else {
                        startButton.textContent = gameMode === 'SINGLE_RACE' ? 'èµ°è¡Œã‚’ã‚„ã‚ã‚‹' : 'RACING...';
                        startButton.disabled = gameMode !== 'SINGLE_RACE'; 
                    }
                    
                    if(gameMode === 'SINGLE_RACE') startButton.classList.remove('race-mode', 'race-mode-2p', 'track1-color', 'track2-color', 'track3-color', 'track4-color');
                    else if (gameMode === 'GRAND_PRIX_1P') {
                        startButton.classList.add('race-mode');
                        startButton.classList.remove('race-mode-2p', 'track1-color', 'track2-color', 'track3-color', 'track4-color');
                    } else if (gameMode === 'GRAND_PRIX_2P') {
                        startButton.classList.add('race-mode-2p');
                        startButton.classList.remove('race-mode', 'track1-color', 'track2-color', 'track3-color', 'track4-color');
                    }
                    
                } else { // count === -1 
                    clearInterval(countdownTimer);
                    countdownDisplay.textContent = '';
                }
            }, 1000);
        }
        function drawMaze() {
            ctx.fillStyle = currentMazeColor; 
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    if (grid[y] && grid[y][x] === 0) { // ğŸš€ å£ã¯ 0
                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
        }
        
        /**
         * ğŸš€ è¿½åŠ : ãƒ‰ãƒƒãƒˆã‚’æç”»ã™ã‚‹é–¢æ•°
         */
        function drawCookies() {
            ctx.fillStyle = '#FFF'; // ç™½è‰²
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    if (grid[y] && grid[y][x] === 1) { // ğŸš€ ãƒ‰ãƒƒãƒˆã¯ 1
                        ctx.beginPath();
                        ctx.arc(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        function drawPacman() {
            let pacmanColor = '#FFFF00'; 
            if (gameMode === 'GRAND_PRIX_2P') {
                 pacmanColor = currentPlayer === 'player1' ? '#FFC000' : '#00AAFF';
            }
            
            ctx.fillStyle = pacman.isBoosting ? '#FF0000' : pacmanColor;
            ctx.beginPath();
            
            const isStopped = (gameState !== 'RACE' && gameState !== 'FREE_RUN') || (pacman.dx === 0 && pacman.dy === 0);

            if (isStopped) {
                ctx.arc(pacman.x, pacman.y, PACMAN_SIZE / 2, 0, Math.PI * 2);
            } else {
                const mouthAngle = 0.2 * Math.PI * Math.abs(Math.sin(Date.now() / 200));
                let startAngle, endAngle;
                if (pacman.dx > 0) { startAngle = mouthAngle; endAngle = 2 * Math.PI - mouthAngle; } 
                else if (pacman.dx < 0) { startAngle = Math.PI + mouthAngle; endAngle = 3 * Math.PI - mouthAngle; } 
                else if (pacman.dy < 0) { startAngle = 1.5 * Math.PI + mouthAngle; endAngle = 3.5 * Math.PI - mouthAngle; } 
                else { startAngle = 0.5 * Math.PI + mouthAngle; endAngle = 2.5 * Math.PI - mouthAngle; }
                ctx.arc(pacman.x, pacman.y, PACMAN_SIZE / 2, startAngle, endAngle);
                ctx.lineTo(pacman.x, pacman.y);
            }
            ctx.fill();
        }
        function attemptMove(dx, dy) {
            if (gameState !== 'FREE_RUN' && gameState !== 'RACE') return;
            const gridX = Math.floor(pacman.x / TILE_SIZE);
            const gridY = Math.floor(pacman.y / TILE_SIZE);
            const nextX = gridX + dx;
            const nextY = gridY + dy;
            const isWall = nextX < 0 || nextX >= MAP_WIDTH || nextY < 0 || nextY >= MAP_HEIGHT || (grid[nextY] && grid[nextY][nextX] === 0);
            if (!isWall) {
                pacman.nextDx = dx;
                pacman.nextDy = dy;
                pacman.turnAttemptTime = Date.now();
            }
        }

        function updatePacman() {
            if (gameState !== 'FREE_RUN' && gameState !== 'RACE') return;

            const currentGridX = Math.floor(pacman.x / TILE_SIZE);
            const currentGridY = Math.floor(pacman.y / TILE_SIZE);
            const centerX = currentGridX * TILE_SIZE + TILE_SIZE / 2;
            const centerY = currentGridY * TILE_SIZE + TILE_SIZE / 2;

            let dx = pacman.dx;
            let dy = pacman.dy;
            let currentSpeed = NORMAL_SPEED;

            if (pacman.isBoosting) {
                if (Date.now() < pacman.boostEndTime) currentSpeed = BOOST_SPEED;
                else pacman.isBoosting = false;
            }

            if (pacman.dx === 0 && pacman.dy === 0 && (pacman.nextDx !== 0 || pacman.nextDy !== 0)) {
                pacman.x = centerX;
                pacman.y = centerY;
                const timeDiff = pacman.turnAttemptTime - pacman.stoppedTime;
                if (pacman.stoppedTime !== 0 && Math.abs(timeDiff) <= TIMING_WINDOW_MS) {
                    pacman.isBoosting = true;
                    pacman.boostEndTime = Date.now() + BOOST_DURATION_MS;
                    currentSpeed = BOOST_SPEED;
                } else {
                    pacman.isBoosting = false;
                }
                pacman.dx = pacman.nextDx;
                pacman.dy = pacman.nextDy;
                pacman.nextDx = 0;
                pacman.nextDy = 0;
                dx = pacman.dx;
                dy = pacman.dy;
            }

            let nextX = pacman.x + dx * currentSpeed;
            let nextY = pacman.y + dy * currentSpeed;
            let stoppedByWall = false;

            if (dx !== 0) {
                const checkX = dx > 0 ? currentGridX + 1 : currentGridX - 1;
                if (checkX >= 0 && checkX < MAP_WIDTH && grid[currentGridY][checkX] === 0) {
                    if ((dx > 0 && nextX + PACMAN_SIZE / 2 > checkX * TILE_SIZE) || (dx < 0 && nextX - PACMAN_SIZE / 2 < (checkX + 1) * TILE_SIZE)) {
                        nextX = dx > 0 ? checkX * TILE_SIZE - PACMAN_SIZE / 2 - 1 : (checkX + 1) * TILE_SIZE + PACMAN_SIZE / 2 + 1;
                        pacman.dx = 0; stoppedByWall = true;
                    }
                }
            }
            if (dy !== 0) {
                const checkY = dy > 0 ? currentGridY + 1 : currentGridY - 1;
                if (checkY >= 0 && checkY < MAP_HEIGHT && grid[checkY][currentGridX] === 0) {
                    if ((dy > 0 && nextY + PACMAN_SIZE / 2 > checkY * TILE_SIZE) || (dy < 0 && nextY - PACMAN_SIZE / 2 < (checkY + 1) * TILE_SIZE)) {
                        nextY = dy > 0 ? checkY * TILE_SIZE - PACMAN_SIZE / 2 - 1 : (checkY + 1) * TILE_SIZE + PACMAN_SIZE / 2 + 1;
                        pacman.dy = 0; stoppedByWall = true;
                    }
                }
            }
            
            // ãƒ¯ãƒ¼ãƒ—ã‚¾ãƒ¼ãƒ³ã®å‡¦ç† (å…¨ã‚³ãƒ¼ã‚¹å…±é€šãƒ­ã‚¸ãƒƒã‚¯ã«ä¿®æ­£)
             const newGridX = Math.floor(nextX / TILE_SIZE);
             const newGridY = Math.floor(nextY / TILE_SIZE);
             
             let warpInY = -1;
             let warpOutX = -1;
             let warpOutY = -1;

             if (currentTrackIndex === 3 && newGridY === 6) { warpInY = 6; } // PINK
             else if (currentTrackIndex === 2 && (newGridY === 5 || newGridY === 7)) { warpInY = newGridY; } // ORANGE
             else if (currentTrackIndex === 0 && newGridY === 5) { warpInY = 5; } // RED
             else if (currentTrackIndex === 1 && (newGridY === 4 || newGridY === 6)) { warpInY = newGridY; } // BLUE

             if (warpInY !== -1) {
                 if (newGridX === -1) { // Left warp
                     warpOutX = MAP_WIDTH - 1;
                     // Determine warp out Y based on track and warpInY
                     if (currentTrackIndex === 3 && warpInY === 6) { warpOutY = 6; }
                     else if (currentTrackIndex === 2 && warpInY === 5) { warpOutY = 7; }
                     else if (currentTrackIndex === 0 && warpInY === 5) { warpOutY = 5; }
                     else if (currentTrackIndex === 1 && warpInY === 6) { warpOutY = 4; }
                 } else if (newGridX === MAP_WIDTH) { // Right warp
                     warpOutX = 0;
                     // Determine warp out Y based on track and warpInY
                     if (currentTrackIndex === 3 && warpInY === 6) { warpOutY = 6; }
                     else if (currentTrackIndex === 2 && warpInY === 7) { warpOutY = 5; }
                     else if (currentTrackIndex === 0 && warpInY === 5) { warpOutY = 5; }
                     else if (currentTrackIndex === 1 && warpInY === 4) { warpOutY = 6; }
                 }

                 if (warpOutX !== -1 && warpOutY !== -1) {
                     nextX = warpOutX * TILE_SIZE + TILE_SIZE / 2; 
                     nextY = warpOutY * TILE_SIZE + TILE_SIZE / 2;        
                     pacman.x = nextX;
                     pacman.y = nextY;
                     return; // Skip remaining update logic after warp
                 }
             }
            
            pacman.x = nextX;
            pacman.y = nextY;

            if (stoppedByWall) {
                pacman.stoppedTime = Date.now();
                pacman.isBoosting = false; 
            } else if (pacman.dx !== 0 || pacman.dy !== 0) {
                 pacman.stoppedTime = 0;
            }
            
            checkCookieCollision();
        }


        function checkCookieCollision() {
            const gridX = Math.floor(pacman.x / TILE_SIZE);
            const gridY = Math.floor(pacman.y / TILE_SIZE);

            if (grid[gridY] && grid[gridY][gridX] === 1) { // ğŸš€ ãƒ‰ãƒƒãƒˆã¯ 1
                grid[gridY][gridX] = 2; // ğŸš€ ç©ºç™½ã¯ 2
                remainingCookies--;

                if (remainingCookies === 0) {
                    const lapTime = Date.now() - lapStartTime;
                    lapTimes.push(lapTime);
                    
                    if (currentLap === 1) lap1TimeDisplay.textContent = formatTime(lapTime);
                    else if (currentLap === 2) lap2TimeDisplay.textContent = formatTime(lapTime);
                    else if (currentLap === 3) {
                         lap3TimeDisplay.textContent = formatTime(lapTime);
                         const totalTime = lapTimes.reduce((a, b) => a + b, 0);
                         totalTimeDisplay.textContent = formatTotalTime(totalTime);
                    }
                    
                    if (currentLap < MAX_LAPS) {
                        currentLap++;
                        resetCookiesForNextLap();
                        lapStartTime = Date.now(); 
                    } else {
                        setTimeout(() => { finishGame(true); }, 200); 
                        startFlashing();
                    }
                }
            }
        }

        function startFlashing() {
            gameState = 'FINISHED_FLASHING'; 
            setTimeout(() => {
                flashCount = 0;
                flashIntervalId = setInterval(flashMaze, 300);
            }, 1000); 
        }

        function flashMaze() {
            flashCount++;
            if (flashCount > FLASH_MAX) { 
                clearInterval(flashIntervalId);
                flashIntervalId = null;
                currentMazeColor = TRACK_COLORS[currentTrackIndex]; 
                
                // ğŸš€ ä¿®æ­£: ç‚¹æ»…çµ‚äº†å¾Œã€finishGameã¯å‘¼ã°ãšã«çŠ¶æ…‹ã‚’å¾©å…ƒ
                if (gameMode === 'SINGLE_RACE') {
                    gameState = 'FINISHED_RESTART'; // ç·´ç¿’ãƒ¢ãƒ¼ãƒ‰å®Œäº†/ä¸­æ–­å¾Œã¯å¸¸ã«ã“ã‚Œ
                } else if (gameMode === 'GRAND_PRIX_1P' || gameMode === 'GRAND_PRIX_2P') {
                    // ã‚°ãƒ©ãƒ³ãƒ—ãƒªã¯ finishGame ã§è¨­å®šã•ã‚ŒãŸçŠ¶æ…‹ (TRACK_FINISHED_WAIT or GRAND_PRIX_WAIT or SHOWING_INTERIM_RESULTS) ã«ãªã‚‹
                     updateTimeAndLapDisplay(); 
                }
                return;
            }
            currentMazeColor = (flashCount % 2 === 1) ? TRACK_COLORS[currentTrackIndex] : '#FFFFFF';
            // æç”»ã¯ gameLoop ã§è¡Œã‚ã‚Œã‚‹
        }
        
        function updateTimeAndLapDisplay() {
            let bestTime = Infinity;
            if (gameMode === 'SINGLE_RACE') {
                bestTime = bestSingleRaceTimes[currentTrackIndex];
            }
            const bestTimeText = bestTime === Infinity ? 'BEST: --:--.---' : `BEST: ${formatTotalTime(bestTime)}`;
            
            if (currentPlayerDisplay) { 
                if (gameMode === 'GRAND_PRIX_2P') {
                     currentPlayerDisplay.textContent = `${grandPrixData[currentPlayer].name} (${TRACKS[currentTrackIndex].name}ã‚³ãƒ¼ã‚¹)`;
                     currentPlayerDisplay.style.color = currentPlayer === 'player1' ? '#FFC000' : '#00AAFF';
                } else if (gameMode === 'GRAND_PRIX_1P') {
                     currentPlayerDisplay.textContent = `1Pãƒ¢ãƒ¼ãƒ‰èµ°è¡Œä¸­ (${TRACKS[currentTrackIndex].name}ã‚³ãƒ¼ã‚¹)`;
                     currentPlayerDisplay.style.color = '#FFC000';
                } else {
                     currentPlayerDisplay.textContent = '';
                }
            }

            if (gameState === 'RACE' || gameState === 'FREE_RUN') {
                const currentTime = Date.now() - lapStartTime + lapTimes.reduce((a, b) => a + b, 0);
                timeDisplay.textContent = `${formatTime(currentTime)}`;
                if (currentBestTimeDisplay) { 
                    currentBestTimeDisplay.textContent = (gameMode === 'SINGLE_RACE') ? bestTimeText : '';
                    currentBestTimeDisplay.style.color = '#FFF'; 
                }
            } else if (gameState === 'FINISHED' || gameState === 'FINISHED_RESTART') { // ğŸš€ ä¿®æ­£: FINISHED_RESTARTã‚‚è€ƒæ…®
                 const totalTime = lapTimes.reduce((a, b) => a + b, 0);
                 if (lapTimes.length === MAX_LAPS) { // å®Œèµ°æ™‚
                     timeDisplay.textContent = `${formatTotalTime(totalTime)}`;
                     if (currentBestTimeDisplay) { 
                         if (gameMode === 'SINGLE_RACE') {
                             currentBestTimeDisplay.textContent = bestTimeText;
                             currentBestTimeDisplay.style.color = (totalTime < bestTime) ? '#00FF00' : '#FFD700'; 
                         } else {
                             currentBestTimeDisplay.textContent = `${grandPrixData[currentPlayer].name} FINISHED`;
                             currentBestTimeDisplay.style.color = currentPlayer === 'player1' ? '#FFC000' : '#00AAFF';
                         }
                     }
                 } else { // ä¸­æ–­æ™‚
                     timeDisplay.textContent = `èµ°è¡Œä¸­æ–­`;
                     if (currentBestTimeDisplay) { 
                        currentBestTimeDisplay.textContent = bestTimeText;
                        currentBestTimeDisplay.style.color = '#FFD700';
                     }
                 }
            } else if (gameState === 'TRACK_FINISHED_WAIT') { // ã“ã®çŠ¶æ…‹ã¯é€šå¸¸ä½¿ã‚ã‚Œãªããªã‚‹
                 const totalTime = lapTimes.reduce((a, b) => a + b, 0);
                 timeDisplay.textContent = ` ${formatTotalTime(totalTime)}`;
                 let nextPlayer = (gameMode === 'GRAND_PRIX_2P') ? (currentPlayer === 'player1' ? 'player2' : 'player1') : 'player1';
                 let nextTrackIndex = currentTrackIndex;
                 if (gameMode === 'GRAND_PRIX_2P' && nextPlayer === 'player1') nextTrackIndex = currentTrackIndex + 1;
                 else if (gameMode === 'GRAND_PRIX_1P') nextTrackIndex = currentTrackIndex + 1;
                 if (nextTrackIndex < TRACKS.length) {
                      if (currentPlayerDisplay) { 
                          currentPlayerDisplay.textContent = `${grandPrixData[nextPlayer].name}ã®ç•ª (${TRACKS[nextTrackIndex].name}ã‚³ãƒ¼ã‚¹)`;
                          currentPlayerDisplay.style.color = nextPlayer === 'player1' ? '#FFC000' : '#00AAFF';
                      }
                      if (currentBestTimeDisplay) currentBestTimeDisplay.textContent = `GO TO NEXT`;
                 } else {
                      if (currentPlayerDisplay) { 
                          currentPlayerDisplay.textContent = `å…¨ã‚³ãƒ¼ã‚¹çµ‚äº†`;
                          currentPlayerDisplay.style.color = '#FFC000';
                      }
                      if (currentBestTimeDisplay) currentBestTimeDisplay.textContent = `çµæœã‚’è¦‹ã‚‹`;
                 }
                 if (currentBestTimeDisplay) currentBestTimeDisplay.style.color = '#FFC000'; 
            } else if (gameState === 'GRAND_PRIX_WAIT') {
                 timeDisplay.textContent = `å…¨ã‚³ãƒ¼ã‚¹çµ‚äº†`;
                 if (currentPlayerDisplay) { 
                     currentPlayerDisplay.textContent = (gameMode === 'GRAND_PRIX_1P') ? `1P COMPLETE` : `2P COMPLETE`;
                     currentPlayerDisplay.style.color = '#FFC000';
                 }
                 if (currentBestTimeDisplay) { 
                     currentBestTimeDisplay.textContent = `COMPLETED`;
                     currentBestTimeDisplay.style.color = '#FFC000';
                 }
            } else if (gameState === 'READY') {
                 timeDisplay.textContent = 'READY';
                 if (currentBestTimeDisplay) { 
                    currentBestTimeDisplay.textContent = (gameMode === 'SINGLE_RACE') ? bestTimeText : '';
                    currentBestTimeDisplay.style.color = '#FFD700';
                 }
                 if (currentPlayerDisplay) { 
                    if (gameMode === 'GRAND_PRIX_2P') {
                          currentPlayerDisplay.textContent = `${grandPrixData[currentPlayer].name}ã®ç•ª (${TRACKS[currentTrackIndex].name}ã‚³ãƒ¼ã‚¹)`;
                          currentPlayerDisplay.style.color = currentPlayer === 'player1' ? '#FFC000' : '#00AAFF';
                    } else if (gameMode === 'GRAND_PRIX_1P') {
                          currentPlayerDisplay.textContent = `1Pãƒ¢ãƒ¼ãƒ‰èµ°è¡Œå‰ (${TRACKS[currentTrackIndex].name}ã‚³ãƒ¼ã‚¹)`;
                          currentPlayerDisplay.style.color = '#FFC000';
                    }
                 }
            } else if (gameState === 'COUNTDOWN') {
                 if (currentBestTimeDisplay) { 
                    currentBestTimeDisplay.textContent = (gameMode === 'SINGLE_RACE') ? bestTimeText : '';
                    currentBestTimeDisplay.style.color = '#FFD700';
                 }
            } else if (gameState === 'FINISHED_FLASHING') {
                const totalTime = lapTimes.reduce((a, b) => a + b, 0);
                timeDisplay.textContent = `${formatTotalTime(totalTime)}`;
                if (currentBestTimeDisplay) { 
                    if (gameMode === 'SINGLE_RACE') {
                         currentBestTimeDisplay.textContent = bestTimeText;
                         currentBestTimeDisplay.style.color = (totalTime < bestTime) ? '#00FF00' : '#FFD700';
                    } else {
                         currentBestTimeDisplay.textContent = `${grandPrixData[currentPlayer].name} FINISHED`;
                         currentBestTimeDisplay.style.color = currentPlayer === 'player1' ? '#FFC000' : '#00AAFF';
                    }
                }
                if (currentPlayerDisplay) { 
                    if (gameMode === 'GRAND_PRIX_2P') {
                          currentPlayerDisplay.textContent = `${grandPrixData[currentPlayer].name} (${TRACKS[currentTrackIndex].name}ã‚³ãƒ¼ã‚¹)`;
                          currentPlayerDisplay.style.color = currentPlayer === 'player1' ? '#FFC000' : '#00AAFF';
                    } else if (gameMode === 'GRAND_PRIX_1P') {
                          currentPlayerDisplay.textContent = `1Pãƒ¢ãƒ¼ãƒ‰èµ°è¡Œä¸­ (${TRACKS[currentTrackIndex].name}ã‚³ãƒ¼ã‚¹)`;
                          currentPlayerDisplay.style.color = '#FFC000';
                    }
                }
            }
        }
        
        function saveBestTimes() {
            localStorage.setItem(`bestTimeTrack${currentTrackIndex}`, bestSingleRaceTimes[currentTrackIndex]);
        }
        
        function updateMenuBestTimes() {
            const displayElement = document.getElementById(`bestTimeTrack${currentTrackIndex}`);
            if (displayElement) {
                displayElement.textContent = 
                    bestSingleRaceTimes[currentTrackIndex] === Infinity ? 'Best: --:--.---' : `Best: ${formatTotalTime(bestSingleRaceTimes[currentTrackIndex])}`;
            }
        }

        /**
         * ğŸš€ ä¿®æ­£: ã‚²ãƒ¼ãƒ çµ‚äº†å‡¦ç† (ã‚°ãƒ©ãƒ³ãƒ—ãƒªé€”ä¸­çµæœè¡¨ç¤ºã‚’è¿½åŠ )
         * @param {boolean} completed - å…¨ãƒ©ãƒƒãƒ—ã‚’å®Œäº†ã—ãŸã‹ã©ã†ã‹
         */
        function finishGame(completed) {
            const totalTime = lapTimes.reduce((a, b) => a + b, 0); 

            if (gameMode === 'SINGLE_RACE') {
                gameState = 'FINISHED_RESTART'; 
                if (completed && totalTime < bestSingleRaceTimes[currentTrackIndex]) {
                    bestSingleRaceTimes[currentTrackIndex] = totalTime;
                    saveBestTimes(); 
                    updateMenuBestTimes(); 
                }
                startButton.textContent = 'RESTART'; 
                startButton.classList.remove('race-mode', 'race-mode-2p', 'track1-color', 'track2-color', 'track3-color', 'track4-color');
                startButton.disabled = false;
                
            } else if ((gameMode === 'GRAND_PRIX_1P' || gameMode === 'GRAND_PRIX_2P') && completed) {
                const resultsArray = grandPrixData[currentPlayer].results;
                const existingResult = resultsArray.find(r => r.trackIndex === currentTrackIndex && r.player === currentPlayer); 
                if (!existingResult) { 
                    resultsArray.push({ trackIndex: currentTrackIndex, trackName: TRACKS[currentTrackIndex].name, time: totalTime, player: currentPlayer });
                }
                
                let nextPlayer = currentPlayer;
                let nextTrackIndex = currentTrackIndex;
                let grandPrixFinished = false;
                if (gameMode === 'GRAND_PRIX_2P') {
                    nextPlayer = currentPlayer === 'player1' ? 'player2' : 'player1';
                    if (nextPlayer === 'player1') nextTrackIndex = currentTrackIndex + 1;
                    if (nextTrackIndex >= TRACKS.length) grandPrixFinished = true;
                } else { // 1P
                    nextTrackIndex = currentTrackIndex + 1;
                    if (nextTrackIndex >= TRACKS.length) grandPrixFinished = true;
                }
                
                if (!grandPrixFinished) {
                    nextTrackForGP = nextTrackIndex; 
                    nextPlayerForGP = nextPlayer;
                    gameState = 'SHOWING_INTERIM_RESULTS'; 
                    showGrandPrixResults(true); 
                    startButton.disabled = true; 
                } else {
                    gameState = 'GRAND_PRIX_WAIT';
                    startButton.textContent = 'ç·åˆçµæœã‚’è¦‹ã‚‹';
                    startButton.disabled = false; 
                    startButton.classList.remove('track1-color', 'track2-color', 'track3-color', 'track4-color');
                    if (gameMode === 'GRAND_PRIX_1P') startButton.classList.add('race-mode');
                    else startButton.classList.add('race-mode-2p');
                }
            }
        }

        /**
         * ğŸš€ ä¿®æ­£: ã‚°ãƒ©ãƒ³ãƒ—ãƒªçµæœè¡¨ç¤º (é€”ä¸­çµæœå¯¾å¿œ)
         * @param {boolean} isInterim - é€”ä¸­çµæœã‹ã©ã†ã‹
         */
        function showGrandPrixResults(isInterim = false) {
            if (!grandPrixResultsDiv) return; 
            grandPrixResultsDiv.style.display = 'block';
            gameUI.style.display = 'none';
            grandPrixScoreList.innerHTML = '';
            grandPrixTotalTime.innerHTML = '';
            
            let totalTimeMs1P = 0;
            let totalTimeMs2P = 0;
            
            let resultHTML = isInterim ? '<h3>é€”ä¸­çµŒé</h3>' : '<h3>æœ€çµ‚çµæœ</h3>';
            
            for(let i = 0; i < TRACKS.length; i++) {
                 const p1ResultForTrack = grandPrixData.player1.results.find(r => r.trackIndex === i);
                 const p2ResultForTrack = grandPrixData.player2.results.find(r => r.trackIndex === i);
                 if (isInterim && i > currentTrackIndex && !(gameMode === 'GRAND_PRIX_2P' && currentPlayer === 'player1' && i === currentTrackIndex)) continue; 

                 const trackName = TRACKS[i].name;
                 resultHTML += `<h4 style="color: ${TRACK_COLORS[i]}; margin-top: 10px; margin-bottom: 5px;">${trackName}ã‚³ãƒ¼ã‚¹</h4>`;
                 
                 const time1P = p1ResultForTrack ? formatTotalTime(p1ResultForTrack.time) : '--:--.---';
                 if (p1ResultForTrack) totalTimeMs1P += p1ResultForTrack.time;
                 
                 if (gameMode === 'GRAND_PRIX_2P') {
                      const time2P = p2ResultForTrack ? formatTotalTime(p2ResultForTrack.time) : '--:--.---';
                      if (p2ResultForTrack) totalTimeMs2P += p2ResultForTrack.time;
                      let class1P = '', class2P = '';
                       if (p1ResultForTrack && p2ResultForTrack) {
                           if (p1ResultForTrack.time < p2ResultForTrack.time) class1P = 'style="color: lime;"';
                           else if (p2ResultForTrack.time < p1ResultForTrack.time) class2P = 'style="color: lime;"';
                       }
                      resultHTML += `<p style="font-size: 16px; margin: 2px 0;"><span style="color: #FFC000;">P1:</span> <span ${class1P}>${time1P}</span></p>`;
                      resultHTML += `<p style="font-size: 16px; margin: 2px 0;"><span style="color: #00AAFF;">P2:</span> <span ${class2P}>${time2P}</span></p>`;
                 } else { // 1P
                      resultHTML += `<p style="font-size: 16px; margin: 2px 0;">Time: ${time1P}</p>`;
                 }
            }
            grandPrixScoreList.innerHTML = resultHTML;

            grandPrixTotalTime.innerHTML += '<hr style="border-top: 1px solid #777; width: 90%; margin-top: 15px;">';
            if (gameMode === 'GRAND_PRIX_2P') {
                 grandPrixTotalTime.innerHTML += `<p style="font-size: 18px; color: #FFC000; margin-bottom: 5px;">P1 Total: ${formatTotalTime(totalTimeMs1P)}</p>`;
                 grandPrixTotalTime.innerHTML += `<p style="font-size: 18px; color: #00AAFF;">P2 Total: ${formatTotalTime(totalTimeMs2P)}</p>`;
                 if (!isInterim) {
                    let winnerText = '';
                    let totalTime = Math.min(totalTimeMs1P, totalTimeMs2P);
                    if (totalTimeMs1P < totalTimeMs2P) winnerText = `ğŸ† å‹è€…: PLAYER 1 (å·®: ${formatTotalTime(totalTimeMs2P - totalTimeMs1P)})`;
                    else if (totalTimeMs2P < totalTimeMs1P) winnerText = `ğŸ† å‹è€…: PLAYER 2 (å·®: ${formatTotalTime(totalTimeMs1P - totalTimeMs2P)})`;
                    else winnerText = `å¼•ãåˆ†ã‘ï¼`;
                    grandPrixTotalTime.innerHTML += `<p style="color: lime; font-weight: bold; margin-top: 10px;">${winnerText}</p>`;
                    if (totalTime < bestGrandPrixTime2P) {
                        bestGrandPrixTime2P = totalTime;
                        localStorage.setItem('bestGrandPrixTime2P', totalTime);
                        grandPrixTotalTime.innerHTML += ' (NEW BEST!)';
                    }
                 }
            } else { // 1P
                 grandPrixTotalTime.innerHTML += `<p style="font-size: 18px;">Total: ${formatTotalTime(totalTimeMs1P)}</p>`;
                 if (!isInterim) { 
                     if (totalTimeMs1P < bestGrandPrixTime1P) {
                         bestGrandPrixTime1P = totalTimeMs1P;
                         localStorage.setItem('bestGrandPrixTime1P', totalTimeMs1P);
                         grandPrixTotalTime.innerHTML += '<span style="color: lime;"> (NEW BEST!)</span>';
                     }
                 }
            }

            const oldButton = document.getElementById('resultButton');
            const newButton = oldButton.cloneNode(true);
            oldButton.parentNode.replaceChild(newButton, oldButton);
            const finalButton = document.getElementById('resultButton'); 

            if (isInterim) {
                finalButton.textContent = 'æ¬¡ã®ãƒ¬ãƒ¼ã‚¹ã¸é€²ã‚€';
                finalButton.style.backgroundColor = '#4CAF50'; 
                finalButton.addEventListener('click', continueGrandPrix); 
            } else {
                finalButton.textContent = 'ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹';
                finalButton.style.backgroundColor = ''; 
                finalButton.addEventListener('click', showMenu); 
            }
        }
        
        function continueGrandPrix() {
            if (grandPrixResultsDiv) grandPrixResultsDiv.style.display = 'none';
            initializeGame(gameMode, nextTrackForGP, nextPlayerForGP);
        }
        
        function finishGrandPrix() {
             gameState = 'GRAND_PRIX_RESULTS';
             showGrandPrixResults(false); 
        }


        function showMenu() {
            gameState = 'MENU';
            startMenu.style.display = 'block';
            grandPrixResultsDiv.style.display = 'none';
            gameUI.style.display = 'none';
            
            loadBestTimes();
            
            bestGrandPrixTimeDisplay1P.textContent = 
                bestGrandPrixTime1P === Infinity ? 'Best: --:--.---' : `Best: ${formatTotalTime(bestGrandPrixTime1P)}`;
            bestGrandPrixTimeDisplay2P.textContent = 
                bestGrandPrixTime2P === Infinity ? 'Best: --:--.---' : `Best: ${formatTotalTime(bestGrandPrixTime2P)}`;

            for (let i = 0; i < TRACKS.length; i++) {
                const displayElement = document.getElementById(`bestTimeTrack${i}`);
                if (displayElement) {
                     displayElement.textContent = 
                        bestSingleRaceTimes[i] === Infinity ? 'Best: --:--.---' : `Best: ${formatTotalTime(bestSingleRaceTimes[i])}`;
                }
            }
            
            // ğŸš€ è¿½åŠ : ã‚¸ãƒ£ã‚¤ãƒ­ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºæ›´æ–°
             const gyroButton = document.getElementById('gyroControlButton');
             if (gyroButton) {
                 if (isGyroControlActive) {
                    gyroButton.textContent = 'âœ… ã‚¸ãƒ£ã‚¤ãƒ­æ“ä½œãŒæœ‰åŠ¹ã§ã™ (ã‚¯ãƒªãƒƒã‚¯ã§è§£é™¤)';
                    gyroButton.style.backgroundColor = '#4CAF50';
                 } else {
                    gyroButton.textContent = 'â–¶ ã‚¸ãƒ£ã‚¤ãƒ­æ“ä½œã‚’æœ‰åŠ¹åŒ–';
                    gyroButton.style.backgroundColor = '#FF9800'; 
                 }
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        function loadBestTimes() {
             const bestGrandPrix1P = localStorage.getItem('bestGrandPrixTime1P');
             bestGrandPrixTime1P = bestGrandPrix1P ? parseInt(bestGrandPrix1P) : Infinity;
             const bestGrandPrix2P = localStorage.getItem('bestGrandPrixTime2P');
             bestGrandPrixTime2P = bestGrandPrix2P ? parseInt(bestGrandPrix2P) : Infinity;
             for (let i = 0; i < TRACKS.length; i++) {
                 const bestSingle = localStorage.getItem(`bestTimeTrack${i}`);
                 bestSingleRaceTimes[i] = bestSingle ? parseInt(bestSingle) : Infinity;
             }
        }

        // ğŸš€ è¿½åŠ : åˆ¶å¾¡ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆé–¢æ•°
// ğŸš€ è¿½åŠ : åˆ¶å¾¡ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆé–¢æ•°
        function setControlMode(mode) {
             controlMode = mode;
             // â–¼â–¼â–¼â–¼â–¼ ä¿®æ­£ç‚¹ 1 â–¼â–¼â–¼â–¼â–¼
             isGyroControlActive = (mode === 'GYRO' || mode === 'ACCELEROMETER');
             // â–²â–²â–²â–²â–² ä¿®æ­£ç‚¹ 1 â–²â–²â–²â–²â–²

             // ä»–ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®çŠ¶æ…‹ã‚’èª¿æ•´
             if (isGyroControlActive) { // (isGyroControlActive ã‚’å‚ç…§ã™ã‚‹ã‚ˆã†ã«ä¿®æ­£)
                 // ã‚¸ãƒ£ã‚¤ãƒ­æœ‰åŠ¹æ™‚ã¯ã‚¿ãƒƒãƒãƒ»ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚’ç„¡åŠ¹åŒ–
                 canvas.removeEventListener('mousedown', handlePointerDown);
                 canvas.removeEventListener('touchstart', handlePointerDown);
                 canvas.removeEventListener('mouseup', handlePointerUp);
                 canvas.removeEventListener('touchend', handlePointerUp);
                 window.removeEventListener('keydown', handleKeyDown);
             } else {
                 // ã‚¸ãƒ£ã‚¤ãƒ­ç„¡åŠ¹æ™‚ã¯ã‚¿ãƒƒãƒãƒ»ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚’å†æœ‰åŠ¹åŒ–
                 canvas.addEventListener('mousedown', handlePointerDown);
                 canvas.addEventListener('touchstart', handlePointerDown);
                 canvas.addEventListener('mouseup', handlePointerUp);
                 canvas.addEventListener('touchend', handlePointerUp);
                 window.addEventListener('keydown', handleKeyDown);
             }
        }


        // ğŸš€ ä¿®æ­£ãƒ»è¿½åŠ ã•ã‚ŒãŸã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
        
        /**
         * ã‚¿ãƒƒãƒ/ãƒã‚¦ã‚¹ã‚¯ãƒªãƒƒã‚¯é–‹å§‹æ™‚ã®å‡¦ç†
         */
        function handlePointerDown(e) { 
            e.preventDefault(); 
            if (isGyroControlActive) return; // ğŸš€ ã‚¸ãƒ£ã‚¤ãƒ­ä¸­ã¯ã‚¹ã‚­ãƒƒãƒ—
            if (gameState !== 'FREE_RUN' && gameState !== 'RACE') return; 
            const isTouch = e.touches && e.touches.length > 0;
            if (isTouch) {
                const rect = canvas.getBoundingClientRect();
                touchStartX = e.touches[0].clientX - rect.left;
                touchStartY = e.touches[0].clientY - rect.top;
            } 
        }
        
        /**
         * ã‚¿ãƒƒãƒ/ãƒã‚¦ã‚¹ã‚¯ãƒªãƒƒã‚¯çµ‚äº†æ™‚ã®å‡¦ç†
         */
        function handlePointerUp(e) { 
            e.preventDefault(); 
            if (isGyroControlActive) return; // ğŸš€ ã‚¸ãƒ£ã‚¤ãƒ­ä¸­ã¯ã‚¹ã‚­ãƒƒãƒ—
            if (gameState !== 'FREE_RUN' && gameState !== 'RACE') return;
            const isTouch = e.changedTouches && e.changedTouches.length > 0;
            if (isTouch) {
                const rect = canvas.getBoundingClientRect();
                const touchEndX = e.changedTouches[0].clientX - rect.left;
                const touchEndY = e.changedTouches[0].clientY - rect.top;
                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;
                if (Math.abs(deltaX) > SWIPE_THRESHOLD || Math.abs(deltaY) > SWIPE_THRESHOLD) {
                    let moveDx = 0, moveDy = 0;
                    if (Math.abs(deltaX) > Math.abs(deltaY)) moveDx = deltaX > 0 ? 1 : -1;
                    else moveDy = deltaY > 0 ? 1 : -1;
                    if (moveDx !== 0 || moveDy !== 0) attemptMove(moveDx, moveDy);
                }
            }
        }

        /**
         * ğŸš€ è¿½åŠ : ãƒ‡ãƒã‚¤ã‚¹ã®å‚¾ãã‚¤ãƒ™ãƒ³ãƒˆã‚’å‡¦ç†ã™ã‚‹é–¢æ•°
         * @param {DeviceOrientationEvent} event 
         */
function handleDeviceMotion(event) {
            // ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ãŒæ“ä½œå¯èƒ½ã§ãªã‘ã‚Œã°ã€ä½•ã‚‚ã—ãªã„
            if (!isGyroControlActive || (gameState !== 'FREE_RUN' && gameState !== 'RACE')) return;

            // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒåŠ ãˆãŸåŠ é€Ÿåº¦ãƒ‡ãƒ¼ã‚¿
            const accel = event.acceleration; 
            
            // â–¼â–¼â–¼â–¼â–¼ ä¿®æ­£ç‚¹ 1 (Yè»¸ -> Zè»¸) â–¼â–¼â–¼â–¼â–¼
            // Yã®ä»£ã‚ã‚Šã«Zã®ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            if (!accel || (accel.x === null && accel.z === null)) return; 
            // â–²â–²â–²â–²â–² ä¿®æ­£ç‚¹ 1 â–²â–²â–²â–²â–²

            // åŠ é€Ÿåº¦ã®çµ¶å¯¾å€¤ãŒæœ€ã‚‚å¤§ãã„æ–¹å‘ã‚’æ¤œå‡º
            const absX = Math.abs(accel.x);
            // const absY = Math.abs(accel.y); // Yè»¸ã¯ä½¿ç”¨ã—ãªã„
            
            // â–¼â–¼â–¼â–¼â–¼ ä¿®æ­£ç‚¹ 2 (Yè»¸ -> Zè»¸) â–¼â–¼â–¼â–¼â–¼
            const absZ = Math.abs(accel.z); // Zè»¸ã®çµ¶å¯¾å€¤ã‚’å–å¾—
            // â–²â–²â–²â–²â–² ä¿®æ­£ç‚¹ 2 â–²â–²â–²â–²â–²

            let moveDx = 0;
            let moveDy = 0;

            // â–¼â–¼â–¼â–¼â–¼ ä¿®æ­£ç‚¹ 3 (Yè»¸ -> Zè»¸) â–¼â–¼â–¼â–¼â–¼
            // Zè»¸ï¼ˆå¥¥/æ‰‹å‰ï¼‰ã®åŠ é€Ÿåº¦ãŒæœ€ã‚‚å¤§ããã€é–¾å€¤ã‚’è¶…ãˆã¦ã„ã‚‹å ´åˆ
            if (absZ > absX && absZ > ACCEL_THRESHOLD) {
                // Zè»¸åŠ é€Ÿåº¦ãŒè² ï¼ˆå¥¥ã«æŒ¯ã£ãŸï¼‰ -> ä¸Šç§»å‹•
                // â€»å¥¥ã«æŒ¯ã‚‹ã¨ã€ç«¯æœ«ã¯æ‰‹å‰ã«åŠ é€Ÿ(Z+)ã€ã¾ãŸã¯å¥¥ã«æ¸›é€Ÿ(Z-)ã—ã¾ã™ã€‚
                //   ç«¯æœ«ã«ã‚ˆã£ã¦Zè»¸ã®å‘ããŒç•°ãªã‚‹å ´åˆãŒã‚ã‚‹ãŸã‚ã€
                //   ã‚‚ã—å‹•ããŒé€†ãªã‚‰ (accel.z > 0) ã«å¤‰æ›´ã—ã¦ãã ã•ã„ã€‚
                if (accel.z < 0) { 
                    moveDy = -1; // ä¸Š
                } 
                // Zè»¸åŠ é€Ÿåº¦ãŒæ­£ï¼ˆæ‰‹å‰ã«æŒ¯ã£ãŸï¼‰ -> ä¸‹ç§»å‹•
                else {
                    moveDy = 1; // ä¸‹
                }
            } 
            // â–²â–²â–²â–²â–² ä¿®æ­£ç‚¹ 3 â–²â–²â–²â–²â–²
            
            // â–¼â–¼â–¼â–¼â–¼ ä¿®æ­£ç‚¹ 4 (Yè»¸ -> Zè»¸) â–¼â–¼â–¼â–¼â–¼
            // Xè»¸ï¼ˆå·¦å³ï¼‰ã®åŠ é€Ÿåº¦ãŒæœ€ã‚‚å¤§ããã€é–¾å€¤ã‚’è¶…ãˆã¦ã„ã‚‹å ´åˆ
            // æ¯”è¼ƒå¯¾è±¡ã‚’ absY ã‹ã‚‰ absZ ã«å¤‰æ›´
            else if (absX > absZ && absX > ACCEL_THRESHOLD) {
            // â–²â–²â–²â–²â–² ä¿®æ­£ç‚¹ 4 â–²â–²â–²â–²â–²
            
                // Xè»¸åŠ é€Ÿåº¦ãŒæ­£ï¼ˆå³ã«æŒ¯ã£ãŸï¼‰ -> å³ç§»å‹•
                if (accel.x > 0) {
                    moveDx = 1; 
                } 
                // Xè»¸åŠ é€Ÿåº¦ãŒè² ï¼ˆå·¦ã«æŒ¯ã£ãŸï¼‰ -> å·¦ç§»å‹•
                else {
                    moveDx = -1; 
                }
            }

            // ç§»å‹•æ–¹å‘ãŒæ±ºå®šã•ã‚ŒãŸå ´åˆã€æ¬¡ã®ç§»å‹•ã‚’è©¦ã¿ã‚‹
            if (moveDx !== 0 || moveDy !== 0) {
                // Xã¨Zã®åŠ é€Ÿåº¦ãŒåŒæ™‚ã«é–¾å€¤ã‚’è¶…ãˆãŸå ´åˆã€çµ¶å¯¾å€¤ãŒå¤§ãã„æ–¹ã‚’å„ªå…ˆã™ã‚‹
                attemptMove(moveDx, moveDy);
            }
        }        function handleKeyDown(e) { 
             if (isGyroControlActive) return; // ğŸš€ ã‚¸ãƒ£ã‚¤ãƒ­ä¸­ã¯ã‚¹ã‚­ãƒƒãƒ—
             if (gameState !== 'FREE_RUN' && gameState !== 'RACE') return; 
             let moveDx = 0, moveDy = 0; 
             switch(e.key) { 
                 case 'ArrowUp': case 'w': moveDy = -1; break; 
                 case 'ArrowDown': case 's': moveDy = 1; break; 
                 case 'ArrowLeft': case 'a': moveDx = -1; break; 
                 case 'ArrowRight': case 'd': moveDx = 1; break; 
             } 
             if (moveDx !== 0 || moveDy !== 0) { 
                 attemptMove(moveDx, moveDy); 
                 e.preventDefault(); 
             } 
         }
        function handleKeyUp(e) { /* No action */ }
        
        canvas.addEventListener('mousedown', handlePointerDown);
        canvas.addEventListener('touchstart', handlePointerDown);
        canvas.addEventListener('mouseup', handlePointerUp);
        canvas.addEventListener('touchend', handlePointerUp);
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);

        let gameLoopRunning = false; 
        function gameLoop(timestamp) {
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMaze();
            drawCookies(); // ğŸš€ ãƒ‰ãƒƒãƒˆã‚’æç”»

            if (gameState === 'RACE' || gameState === 'FREE_RUN' || gameState === 'FINISHED_FLASHING') {
                updatePacman();
            } 
            if (gameState !== 'FINISHED_FLASHING' || (flashCount % 2 === 1)) { 
                drawPacman(); 
            }
            
            updateTimeAndLapDisplay();
            
            requestAnimationFrame(gameLoop);
        }
        

        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        
        grandPrixButton1P.addEventListener('click', () => {
            grandPrixData.player1.results = []; 
            grandPrixData.player2.results = []; 
            initializeGame('GRAND_PRIX_1P', 0, 'player1'); 
        });
        
        grandPrixButton2P.addEventListener('click', () => {
            grandPrixData.player1.results = []; 
            grandPrixData.player2.results = []; 
            initializeGame('GRAND_PRIX_2P', 0, 'player1'); 
        });

        document.querySelectorAll('#track-grid .mode-button').forEach(button => {
            button.addEventListener('click', (e) => {
                const targetButton = e.target.closest('.mode-button');
                const trackIndex = parseInt(targetButton.dataset.trackIndex);
                initializeGame('SINGLE_RACE', trackIndex); 
            });
        });

        // ğŸš€ resultButtonã®ãƒªã‚¹ãƒŠãƒ¼ã¯ showGrandPrixResults ã§å‹•çš„ã«è¨­å®šã•ã‚Œã‚‹

        document.getElementById('returnToMenuButtonGame').addEventListener('click', () => {
            if (gameState === 'COUNTDOWN') {
                clearInterval(countdownTimer);
                countdownDisplay.textContent = '';
            }
            showMenu();
        });


        /**
         * ğŸš€ ä¿®æ­£: startButton ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
         */
        startButton.addEventListener('click', () => {
            if (gameState === 'READY') {
                if (gameMode === 'SINGLE_RACE' || gameMode === 'GRAND_PRIX_1P' || gameMode === 'GRAND_PRIX_2P') {
                    startCountdown();
                }
            } else if (gameState === 'FREE_RUN') {
                finishGame(false); // ä¸­æ–­å‡¦ç†ã¸
            } else if (gameState === 'FINISHED') {
                // ã‚°ãƒ©ãƒ³ãƒ—ãƒªå®Œäº†æ™‚ã®ã¿ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹ (SINGLE_RACEã¯FINISHED_RESTARTã§å‡¦ç†)
                if (gameMode !== 'SINGLE_RACE') {
                     showMenu();
                }
            } else if (gameState === 'FINISHED_RESTART') { // ç·´ç¿’èµ°è¡Œã®ä¸­æ–­å¾Œ ã¾ãŸã¯ å®Œäº†å¾Œ
                initializeGame('SINGLE_RACE', currentTrackIndex); // RESTART
            } else if (gameState === 'TRACK_FINISHED_WAIT') { 
                console.warn("Unexpected state: TRACK_FINISHED_WAIT reached via startButton");
                 let nextTrackIndex = currentTrackIndex;
                 let nextPlayer = currentPlayer;
                 if (gameMode === 'GRAND_PRIX_2P') {
                     nextPlayer = currentPlayer === 'player1' ? 'player2' : 'player1';
                     if (nextPlayer === 'player1') nextTrackIndex = currentTrackIndex + 1; 
                 } else { 
                     nextTrackIndex = currentTrackIndex + 1;
                     nextPlayer = 'player1'; 
                 }
                 initializeGame(gameMode, nextTrackIndex, nextPlayer);
            } else if (gameState === 'GRAND_PRIX_WAIT') { 
                finishGrandPrix(); // æœ€çµ‚çµæœç”»é¢ã¸ç§»è¡Œ
            }
            // ğŸš€ SHOWING_INTERIM_RESULTS çŠ¶æ…‹ã§ã¯ startButton ã¯ç„¡åŠ¹åŒ–ã•ã‚Œã¦ã„ã‚‹ã¯ãš
        });
        
// åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼ (DeviceMotionEvent) ã®æœ‰åŠ¹åŒ–ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆã™ã‚‹
        function requestDeviceMotionPermission() {
            // iOS 13ä»¥é™ã§è¨±å¯ãŒå¿…è¦ãªå ´åˆ
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission().then(permissionState => {
                    if (permissionState === 'granted') {
                        window.addEventListener('devicemotion', handleDeviceMotion);
                        setControlMode('ACCELEROMETER'); // åˆ¶å¾¡ãƒ¢ãƒ¼ãƒ‰ã‚’ACCELEROMETERã«è¨­å®š
                        gyroControlButton.textContent = 'âœ… æŒ¯ã‚‹æ“ä½œãŒæœ‰åŠ¹ã§ã™ (ã‚¯ãƒªãƒƒã‚¯ã§è§£é™¤)';
                        gyroControlButton.style.backgroundColor = '#4CAF50';
                    } else {
                        alert('åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚');
                    }
                })
                .catch(error => {
                     console.error("åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼è¨±å¯ã‚¨ãƒ©ãƒ¼:", error);
                     alert('åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼ã®æœ‰åŠ¹åŒ–ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚'); // â† ã“ã‚Œã§ã‚¨ãƒ©ãƒ¼å†…å®¹ãŒæ­£ç¢ºã«ãªã‚‹
                });
            } else {
                // iOS 13æœªæº€ã‚„Androidãªã©ã€è¨±å¯ãŒä¸è¦ãªç’°å¢ƒ
                if ('DeviceMotionEvent' in window) {
                    window.addEventListener('devicemotion', handleDeviceMotion);
                    setControlMode('ACCELEROMETER'); // åˆ¶å¾¡ãƒ¢ãƒ¼ãƒ‰ã‚’ACCELEROMETERã«è¨­å®š
                    gyroControlButton.textContent = 'âœ… æŒ¯ã‚‹æ“ä½œãŒæœ‰åŠ¹ã§ã™ (ã‚¯ãƒªãƒƒã‚¯ã§è§£é™¤)';
                    gyroControlButton.style.backgroundColor = '#4CAF50';
                } else {
                    alert('ãŠä½¿ã„ã®ãƒ‡ãƒã‚¤ã‚¹ã¾ãŸã¯ãƒ–ãƒ©ã‚¦ã‚¶ã¯åŠ é€Ÿåº¦ã‚»ãƒ³ã‚µãƒ¼ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚');
                }
            }
        }

if (gyroControlButton) {
             gyroControlButton.addEventListener('click', () => {
                 // â–¼â–¼â–¼â–¼â–¼ ä¿®æ­£ç‚¹ 2 â–¼â–¼â–¼â–¼â–¼
                 if (controlMode === 'ACCELEROMETER') {
                 // â–²â–²â–²â–²â–² ä¿®æ­£ç‚¹ 2 â–²â–²â–²â–²â–²
                 
                     // è§£é™¤
                     window.removeEventListener('devicemotion', handleDeviceMotion);
                     setControlMode('SWIPE'); 
                     gyroControlButton.textContent = 'â–¶ æŒ¯ã‚‹æ“ä½œã‚’æœ‰åŠ¹åŒ–';
                     gyroControlButton.style.backgroundColor = '#FF9800'; 
                 } else {
                     // æœ‰åŠ¹åŒ–
                     requestDeviceMotionPermission(); // å¤‰æ›´å¾Œã®é–¢æ•°ã‚’å‘¼ã³å‡ºã—
                 }
             });
        }

        // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã®åˆæœŸåŒ–
        showMenu(); 
    </script>

</body>
</html>